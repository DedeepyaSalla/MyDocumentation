{\rtf1\ansi\ansicpg1252\cocoartf2706
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red93\green108\blue121;
}
{\*\expandedcolortbl;;\csgenericrgb\c0\c0\c0\c85000;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c36526\c42188\c47515;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\})}{\leveltext\leveltemplateid101\'02\'00);}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid102\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid103\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid104\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li2880\lin2880 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid105\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li3600\lin3600 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\paperw11900\paperh16840\margl1440\margr1440\vieww17740\viewh10920\viewkind0
\deftab692
\pard\tx692\pardeftab692\partightenfactor0

\f0\fs28 \cf2 \cb3 \
\cf4  concepts Covered here \
\pard\tx220\tx720\pardeftab692\li720\fi-720\partightenfactor0
\ls1\ilvl0
\f1\b \cf4 {\listtext	1.	}Understand syntax for everything, Generics\
\pard\tx220\tx720\tx1440\tx2160\pardeftab692\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf2 {\listtext	2.	}How can you understand about types and analyse?\
\ls1\ilvl0
\f0\b0 \cf4 {\listtext	3.	}\
\pard\tx692\pardeftab692\partightenfactor0
\cf2 \
\pard\tx220\tx720\pardeftab692\li720\fi-720\partightenfactor0
\ls2\ilvl0
\f1\b \cf4 {\listtext	1)	} Understand syntax for everything, Generics
\f0\b0 \cf2 \
\pard\tx940\tx1440\pardeftab692\li1440\fi-1440\partightenfactor0
\ls2\ilvl1\cf4 {\listtext	\uc0\u8259 	}Understsand that any advancements will be built based on basic concepts only.
\f1\b \cf2  So try to understand that generic is build from that kind of basics only. If a generic property exits then first look at how regular property is declared, then you will understand generic property syntax and if a generic function exits, then you will understand how to declare it only first if you understand regular function.\
\ls2\ilvl1
\f0\b0 \cf4 {\listtext	\uc0\u8259 	}along with similarity with basic concepts, obviously this new enhancements will have their own custom features shipped along with them.\
\pard\tx1660\tx2160\pardeftab692\li2160\fi-2160\partightenfactor0
\ls2\ilvl2\cf4 {\listtext	\uc0\u8259 	}In generics if you consider function generic, just like normal function - arg: generic type can be declared.\
{\listtext	\uc0\u8259 	}Extra features: \
\pard\tx2380\tx2880\pardeftab692\li2880\fi-2880\partightenfactor0
\ls2\ilvl3\cf4 {\listtext	\uc0\u8259 	}But along with this you have to <T,Q> all generics you pass for input and return type. Then compiler will know they are generics.\
{\listtext	\uc0\u8259 	}Esp, if you have return type as generic eg: Q. Then compiler will have no clue to understand if are returning proper return type which is of type \'91Q\'92. For that either you r input must be \'91Q\'92 type or else you must type cast ur returning value as \'91Q\'92. So by looking at this you must understand that you cannot just declare generic and anyway it is generic so you can return whatever you want. \
{\listtext	\uc0\u8259 	}Basically, function syntax will be in two places. Function declaration and function call. So whatever you declared must match with function call. \
\pard\tx940\tx1440\pardeftab692\li1440\fi-1440\partightenfactor0
\ls2\ilvl1
\f1\b \cf2 {\listtext	\uc0\u8259 	}Generics
\f0\b0 \
\pard\tx1660\tx2160\pardeftab692\li2160\fi-2160\partightenfactor0
\ls2\ilvl2\cf2 {\listtext	\uc0\u8259 	}If you look at 
\f1\b function
\f0\b0 , it contains
\f1\b  arguments: DataType (eg: name: String) and return Type if it exists
\f0\b0 . But instead of inbuilt return types if you pass ur own data type \'92T
\f1\b  (eg: name: T)
\f0\b0 , then
\f1\b  
\f0\b0 compiler cannot understand what dataTypes it should accept. Instead if you tell \'92T\'92 is generic, then compiler won\'92t give any error. It takes \'92T\'92 as a custom data type\
\pard\tx220\tx720\tx1440\tx2160\pardeftab692\li720\fi-720\partightenfactor0
\ls2\ilvl0
\f1\b \cf2 {\listtext	2)	}How can you understand about types and analyse?
\f0\b0 \
\pard\tx2380\tx2880\pardeftab692\li2880\fi-2880\partightenfactor0
\ls2\ilvl3\cf2 {\listtext	\uc0\u8259 	}Datatypes and types. 
\f1\b DataTypes means it holds data like string, Int, arrays etc
\f0\b0 . 
\f1\b Types means it can be anything including dataTypes. 
\f0\b0 \
\pard\tx3100\tx3600\pardeftab692\li3600\fi-3600\partightenfactor0
\ls2\ilvl4\cf2 {\listtext	\uc0\u8259 	}
\f1\b Inbuild DataTypes: Int, String etc primitive datatypes. Sequences like array, dict, sets\
{\listtext	\uc0\u8259 	}Types in Swift are: Class, Struct, Enums, Protocol, Generic
\f0\b0 \
\pard\tx2380\tx2880\pardeftab692\li2880\fi-2880\partightenfactor0
\ls2\ilvl3\cf2 {\listtext	\uc0\u8259 	}It means if you declare type of argument for function as String, it accepts only string. If you declare type as eg:class Person, it only accepts Person objects. Similarly, if you declare argument type as \'91Protocol\'92, then it accepts only objects which confirm the protocol
\f1\b  (confirm means which implements its properties and functions as declared in protocol)
\f0\b0 . If you look at catch here \
\pard\tx3100\tx3600\pardeftab692\li3600\fi-3600\partightenfactor0
\ls2\ilvl4\cf2 {\listtext	\uc0\u8259 	}eg: person: ClassPerson -> it means person is class objects which contains its properties and functions\
{\listtext	\uc0\u8259 	}eg: person: protocolBrake -> it means here person is of type protocol protocolBrake. So it means indirectly that this person object confirms to this protocol. Why it is so? Because class basic functionality is to hold all its properties and functions, but protocol basic functionality is for any objects to just implement its variables and functions.\
}